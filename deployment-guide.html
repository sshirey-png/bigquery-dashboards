<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claude Code Deployment Guide</title>
<style>
  :root {
    --ink: #1a1816;
    --text: #2d2d2d;
    --muted: #6b6560;
    --light-muted: #8a8580;
    --bg: #faf8f5;
    --card-bg: #f5f2ed;
    --border: #d5d0c8;
    --accent: #2563eb;
    --accent-muted: #3b82f6;
    --code-bg: #1e1e2e;
    --code-text: #cdd6f4;
    --code-comment: #6c7086;
    --code-keyword: #cba6f7;
    --code-string: #a6e3a1;
    --code-prop: #89b4fa;
    --warning-bg: #fef3c7;
    --warning-border: #d97706;
    --danger-bg: #fee2e2;
    --danger-border: #dc2626;
    --success-bg: #dcfce7;
    --success-border: #16a34a;
    --layer1: #7c3aed;
    --layer2: #2563eb;
    --layer3: #0891b2;
    --layer4: #059669;
    --layer5: #dc2626;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 16px;
    line-height: 1.7;
    color: var(--text);
    background: var(--bg);
  }

  /* Header */
  .header {
    background: var(--ink);
    color: #f5f2ed;
    padding: 48px 0 40px;
    text-align: center;
  }
  .header .label {
    font-family: 'Menlo', 'Consolas', monospace;
    font-size: 11px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--accent-muted);
    margin-bottom: 16px;
  }
  .header h1 {
    font-size: 32px;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 12px;
    letter-spacing: -0.5px;
  }
  .header .subtitle {
    font-size: 15px;
    color: #a09a94;
    max-width: 520px;
    margin: 0 auto;
    line-height: 1.5;
  }
  .header .meta {
    font-family: 'Menlo', 'Consolas', monospace;
    font-size: 11px;
    color: #6b6560;
    margin-top: 20px;
  }

  /* Layout */
  .container {
    max-width: 780px;
    margin: 0 auto;
    padding: 0 24px;
  }

  /* Navigation */
  .toc {
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 28px 32px;
    margin: 40px 0;
  }
  .toc h2 {
    font-size: 13px;
    font-family: 'Menlo', 'Consolas', monospace;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--muted);
    margin-bottom: 16px;
  }
  .toc ol {
    padding-left: 20px;
  }
  .toc li {
    margin: 6px 0;
    font-size: 15px;
  }
  .toc a {
    color: var(--accent);
    text-decoration: none;
  }
  .toc a:hover { text-decoration: underline; }

  /* Sections */
  section {
    margin: 48px 0;
    padding-top: 8px;
  }
  h2 {
    font-size: 24px;
    font-weight: 700;
    color: var(--ink);
    margin-bottom: 20px;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--border);
  }
  h3 {
    font-size: 18px;
    font-weight: 700;
    color: var(--ink);
    margin: 28px 0 12px;
  }
  h4 {
    font-size: 15px;
    font-weight: 700;
    color: var(--ink);
    margin: 20px 0 8px;
  }
  p {
    margin-bottom: 16px;
  }
  strong { color: var(--ink); }

  /* Lists */
  ul, ol {
    margin: 0 0 16px 24px;
  }
  li {
    margin: 6px 0;
  }

  /* Tables */
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0 24px;
    font-size: 14px;
  }
  th {
    text-align: left;
    font-weight: 700;
    color: var(--ink);
    background: var(--card-bg);
    padding: 10px 14px;
    border-bottom: 2px solid var(--border);
    font-size: 12px;
    font-family: 'Menlo', 'Consolas', monospace;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  td {
    padding: 10px 14px;
    border-bottom: 1px solid var(--border);
    vertical-align: top;
  }
  tr:last-child td { border-bottom: none; }

  /* Code */
  code {
    font-family: 'Menlo', 'Consolas', 'Monaco', monospace;
    font-size: 13px;
    background: var(--card-bg);
    padding: 2px 6px;
    border-radius: 3px;
    color: var(--ink);
  }
  pre {
    background: var(--code-bg);
    color: var(--code-text);
    padding: 20px 24px;
    border-radius: 6px;
    overflow-x: auto;
    margin: 16px 0 24px;
    font-size: 13px;
    line-height: 1.6;
    position: relative;
  }
  pre code {
    background: none;
    padding: 0;
    color: inherit;
    font-size: inherit;
  }
  .code-label {
    position: absolute;
    top: 8px;
    right: 12px;
    font-family: 'Menlo', 'Consolas', monospace;
    font-size: 10px;
    color: var(--code-comment);
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .comment { color: var(--code-comment); }
  .keyword { color: var(--code-keyword); }
  .string { color: var(--code-string); }
  .prop { color: var(--code-prop); }

  /* Copy button */
  .copy-btn {
    position: absolute;
    top: 8px;
    right: 12px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    color: var(--code-comment);
    font-family: 'Menlo', 'Consolas', monospace;
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 3px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .copy-btn:hover {
    background: rgba(255,255,255,0.15);
    color: var(--code-text);
  }

  /* Callouts */
  .callout {
    padding: 16px 20px;
    border-left: 4px solid;
    border-radius: 0 6px 6px 0;
    margin: 20px 0;
    font-size: 14px;
  }
  .callout-warning {
    background: var(--warning-bg);
    border-color: var(--warning-border);
  }
  .callout-danger {
    background: var(--danger-bg);
    border-color: var(--danger-border);
  }
  .callout-success {
    background: var(--success-bg);
    border-color: var(--success-border);
  }
  .callout-info {
    background: #eff6ff;
    border-color: var(--accent);
  }
  .callout strong {
    display: block;
    margin-bottom: 4px;
  }

  /* Architecture diagram */
  .arch-diagram {
    background: var(--code-bg);
    color: var(--code-text);
    padding: 24px 28px;
    border-radius: 6px;
    font-family: 'Menlo', 'Consolas', monospace;
    font-size: 12px;
    line-height: 1.5;
    overflow-x: auto;
    margin: 20px 0 28px;
  }
  .arch-diagram .l1 { color: var(--layer1); }
  .arch-diagram .l2 { color: var(--layer2); }
  .arch-diagram .l3 { color: var(--layer3); }
  .arch-diagram .l4 { color: var(--layer4); }
  .arch-diagram .l5 { color: var(--layer5); }
  .arch-diagram .dim { color: var(--code-comment); }

  /* Collapsible sections */
  details {
    margin: 16px 0;
    border: 1px solid var(--border);
    border-radius: 6px;
    overflow: hidden;
  }
  summary {
    padding: 14px 20px;
    background: var(--card-bg);
    cursor: pointer;
    font-weight: 700;
    font-size: 15px;
    color: var(--ink);
    user-select: none;
    list-style: none;
  }
  summary::-webkit-details-marker { display: none; }
  summary::before {
    content: '\25B6';
    display: inline-block;
    margin-right: 10px;
    font-size: 11px;
    transition: transform 0.15s;
    color: var(--muted);
  }
  details[open] summary::before {
    transform: rotate(90deg);
  }
  details .detail-content {
    padding: 20px 24px;
    border-top: 1px solid var(--border);
  }
  details pre {
    margin: 12px 0;
  }

  /* Layer badges */
  .layer-badge {
    display: inline-block;
    font-family: 'Menlo', 'Consolas', monospace;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 3px 8px;
    border-radius: 3px;
    color: #fff;
    margin-right: 8px;
    vertical-align: middle;
  }
  .badge-l1 { background: var(--layer1); }
  .badge-l2 { background: var(--layer2); }
  .badge-l3 { background: var(--layer3); }
  .badge-l4 { background: var(--layer4); }
  .badge-l5 { background: var(--layer5); }

  /* Checklist */
  .checklist {
    list-style: none;
    padding: 0;
    margin: 16px 0 24px;
  }
  .checklist li {
    padding: 8px 0 8px 32px;
    position: relative;
    border-bottom: 1px solid var(--border);
    font-size: 14px;
  }
  .checklist li:last-child { border-bottom: none; }
  .checklist li::before {
    content: '';
    position: absolute;
    left: 0;
    top: 10px;
    width: 18px;
    height: 18px;
    border: 2px solid var(--border);
    border-radius: 3px;
  }

  /* Separator */
  hr {
    border: none;
    border-top: 1px solid var(--border);
    margin: 40px 0;
  }

  /* Footer */
  .footer {
    text-align: center;
    padding: 40px 0 60px;
    color: var(--light-muted);
    font-size: 13px;
    font-style: italic;
  }

  /* Print styles */
  @media print {
    .header { background: #fff; color: var(--ink); padding: 20px 0; }
    .header .label { color: var(--muted); }
    .header .subtitle { color: var(--muted); }
    pre { background: #f5f5f5; color: var(--ink); border: 1px solid #ddd; }
    pre code { color: var(--ink); }
    .copy-btn { display: none; }
    details { border: 1px solid #ddd; }
    details[open] summary { border-bottom: 1px solid #ddd; }
    .arch-diagram { background: #f5f5f5; color: var(--ink); border: 1px solid #ddd; }
    .arch-diagram .l1, .arch-diagram .l2, .arch-diagram .l3,
    .arch-diagram .l4, .arch-diagram .l5 { color: var(--ink); font-weight: 700; }
    body { font-size: 12px; }
    section { margin: 24px 0; }
  }

  @media (max-width: 600px) {
    .header h1 { font-size: 24px; }
    .container { padding: 0 16px; }
    pre { padding: 14px 16px; font-size: 12px; }
    table { font-size: 12px; }
    th, td { padding: 8px 10px; }
  }
</style>
</head>
<body>

<div class="header">
  <div class="container">
    <p class="label">Infrastructure Guide</p>
    <h1>Claude Code Deployment Guide</h1>
    <p class="subtitle">Persistent memory, security controls, and operational practices for professional Claude Code environments.</p>
    <p class="meta">Dr. Nadia Okafor / February 24, 2026</p>
  </div>
</div>

<div class="container">

  <nav class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#why">Why This Matters</a></li>
      <li><a href="#architecture">The Architecture</a></li>
      <li><a href="#setup">Setup Guide</a></li>
      <li><a href="#security">Security Checklist</a></li>
      <li><a href="#maintenance">Maintenance &amp; Hygiene</a></li>
      <li><a href="#quickstart">Quick-Start Template</a></li>
    </ol>
  </nav>

  <!-- ============================================================ -->
  <section id="why">
    <h2>1. Why This Matters</h2>

    <h3>The Session Continuity Problem</h3>
    <p>Claude Code sessions are stateless by default. Every new session starts from zero. The agent does not know what you built yesterday, what naming conventions you use, what credentials must never appear in code, or what mistakes it has already been corrected on.</p>

    <p>Without persistent infrastructure, you are the memory. You repeat context. You re-explain conventions. You catch the same mistakes the agent made two sessions ago. This scales poorly.</p>

    <h3>Case Study: Context Loss</h3>
    <p>A developer was mid-session building a Next.js feature. His machine shut down unexpectedly. When he restarted Claude Code, the agent could not locate the project -- it had been referenced by a relative path in the conversation, and the session transcript was gone. The developer spent hours reconstructing where he was, what he had changed, and what remained to do. The code changes were in the working directory, but the <em>context</em> -- the intent, the decisions, the approach -- was lost.</p>

    <p>This was not a Claude Code bug. It was an infrastructure gap. The project had no CLAUDE.md, no context files, no session hook. The agent had no way to re-orient itself.</p>

    <h3>The Cost Equation</h3>
    <table>
      <tr><th>Action</th><th>Time Cost</th><th>Frequency</th></tr>
      <tr><td>Setting up persistent infrastructure</td><td>30-60 minutes (once)</td><td>Per project</td></tr>
      <tr><td>Rebuilding context from scratch each session</td><td>5-15 minutes</td><td>Every session</td></tr>
      <tr><td>Recovering from total context loss</td><td>1-4 hours</td><td>Every crash or ambiguous state</td></tr>
      <tr><td>Debugging a mistake the agent already learned about</td><td>15-45 minutes</td><td>Every time context is lost</td></tr>
    </table>

    <p>The infrastructure pays for itself within a week of daily use.</p>
  </section>

  <!-- ============================================================ -->
  <section id="architecture">
    <h2>2. The Architecture</h2>

    <p>Five layers, each independent, each additive. Adopt them incrementally.</p>

    <div class="arch-diagram">
<span class="dim">                    ┌─────────────────────────────────┐</span>
<span class="l5">  Layer 5: Security │</span> gitleaks, .gitignore, cred rules <span class="l5">│</span>
<span class="dim">                    ├─────────────────────────────────┤</span>
<span class="l4">  Layer 4: Hooks    │</span> SessionStart, PreCompact, Stop   <span class="l4">│</span>
<span class="dim">                    ├─────────────────────────────────┤</span>
<span class="l3">  Layer 3: Memory   │</span> ~/.claude/projects/*/memory/     <span class="l3">│</span>
<span class="dim">                    ├─────────────────────────────────┤</span>
<span class="l2">  Layer 2: Project  │</span> CLAUDE.md, .claude/context/      <span class="l2">│</span>
<span class="dim">                    ├─────────────────────────────────┤</span>
<span class="l1">  Layer 1: Global   │</span> ~/.claude/CLAUDE.md, settings    <span class="l1">│</span>
<span class="dim">                    └─────────────────────────────────┘</span>

<span class="dim">  Data flows up. Global sets defaults. Project overrides.
  Context accumulates. Memory captures. Hooks enforce.
  Security prevents leaks at every layer.</span>
    </div>

    <h3><span class="layer-badge badge-l1">L1</span> Global Config</h3>
    <p><code>~/.claude/CLAUDE.md</code> and <code>~/.claude/settings.json</code> load into every session, regardless of project. Use the global config for your name, cross-project preferences, and behavioral rules that apply everywhere.</p>

    <table>
      <tr><th>File</th><th>Purpose</th><th>Loaded</th></tr>
      <tr><td><code>~/.claude/CLAUDE.md</code></td><td>Global instructions</td><td>Always, every session</td></tr>
      <tr><td><code>~/.claude/settings.json</code></td><td>Global hooks, model prefs, plugins</td><td>Always, every session</td></tr>
      <tr><td><code>~/.claude/skills/</code></td><td>Installed skills (optional)</td><td>On invocation</td></tr>
    </table>

    <h3><span class="layer-badge badge-l2">L2</span> Project Config</h3>
    <p>Each project gets its own <code>CLAUDE.md</code> in the repo root, plus a <code>.claude/</code> directory for context files, hooks, and settings.</p>

    <table>
      <tr><th>File</th><th>Purpose</th><th>Version Controlled</th></tr>
      <tr><td><code>CLAUDE.md</code></td><td>Project instructions, rules, mandatory actions</td><td>Yes</td></tr>
      <tr><td><code>.claude/context/*.md</code></td><td>Domain knowledge, gotchas, conventions</td><td>Yes</td></tr>
      <tr><td><code>.claude/settings.json</code></td><td>Project-specific hooks</td><td>Yes</td></tr>
      <tr><td><code>.claude/hooks/*.sh</code></td><td>Hook scripts</td><td>Yes</td></tr>
      <tr><td><code>.claude/LAST_SESSION.md</code></td><td>Generated session state</td><td>No (.gitignore)</td></tr>
    </table>

    <div class="callout callout-info">
      <strong>CLAUDE.md is instructions. Context files are knowledge.</strong>
      CLAUDE.md tells the agent how to behave. Context files tell it what it knows. Keep them separate. CLAUDE.md should be lean (under 100 lines). Context files can grow -- but manage that growth.
    </div>

    <h3><span class="layer-badge badge-l3">L3</span> Auto-Memory</h3>
    <p>Claude Code automatically maintains <code>MEMORY.md</code> at <code>~/.claude/projects/&lt;path-hash&gt;/memory/</code>. The first 200 lines are loaded into every session.</p>

    <div class="callout callout-danger">
      <strong>200-line hard limit.</strong>
      Lines beyond 200 are silently truncated. The agent never sees them. Knowledge is lost without warning. If your MEMORY.md grows past 180 lines, move detailed content into topic files in the same directory and keep MEMORY.md as an index.
    </div>

    <h3><span class="layer-badge badge-l4">L4</span> Session Hooks</h3>
    <p>Hooks run automatically at defined lifecycle events. The three that matter:</p>

    <table>
      <tr><th>Hook</th><th>When</th><th>Use For</th></tr>
      <tr><td><code>SessionStart</code></td><td>Session opens</td><td>Generate LAST_SESSION.md, pull latest git changes</td></tr>
      <tr><td><code>PreCompact</code></td><td>Before context compression</td><td>Remind agent to save learnings</td></tr>
      <tr><td><code>Stop</code></td><td>Agent finishes</td><td>Cleanup checks (debug statements, uncommitted files)</td></tr>
    </table>

    <h3><span class="layer-badge badge-l5">L5</span> Security</h3>
    <p>Three controls, non-negotiable for any project that touches credentials or client data:</p>
    <ol>
      <li><strong>gitleaks pre-commit hook</strong> -- catches secrets before they enter git history</li>
      <li><strong>.gitignore patterns</strong> -- prevents secrets files from being tracked</li>
      <li><strong>Credential hygiene rules</strong> -- never in chat, never in code, env vars only</li>
    </ol>
  </section>

  <!-- ============================================================ -->
  <section id="setup">
    <h2>3. Setup Guide</h2>

    <p>Start from a fresh Claude Code installation. Each step is copy-paste ready.</p>

    <details>
      <summary>Step 1: Create Global Config (~/.claude/CLAUDE.md)</summary>
      <div class="detail-content">
        <p>This file loads into every Claude Code session across all projects.</p>
        <pre><code><span class="comment"># ~/.claude/CLAUDE.md</span>

<span class="keyword"># Global Claude Code Configuration</span>

<span class="prop">**Owner:**</span> [Your Name]

---

<span class="keyword">## Session Start Routine</span>

At the start of each session:
1. Read project-specific context if it exists (.claude/context/)
2. Greet [Your Name] with brief context from prior session

---

<span class="keyword">## Preferences</span>

- [Your communication style preferences]
- [Your tool preferences, e.g., "CLI over web console"]
- [Your code style preferences]

---

<span class="keyword">## Projects</span>

| Project | Directory |
|---------|-----------|
| [Project 1] | ~/path/to/project1 |
| [Project 2] | ~/path/to/project2 |</code></pre>

        <p>Keep this under 80 lines. It loads into <em>every</em> session -- bloat here costs context everywhere.</p>
      </div>
    </details>

    <details>
      <summary>Step 2: Create Global Settings (~/.claude/settings.json)</summary>
      <div class="detail-content">
        <p>Global hooks that apply across all projects. These three are recommended:</p>
        <pre><code>{
  <span class="prop">"hooks"</span>: {
    <span class="prop">"PreToolUse"</span>: [
      {
        <span class="prop">"matcher"</span>: <span class="string">"tool == \"Write\" && tool_input.file_path matches \"\\\\.md$\""</span>,
        <span class="prop">"hooks"</span>: [
          {
            <span class="prop">"type"</span>: <span class="string">"command"</span>,
            <span class="prop">"command"</span>: <span class="string">"#!/bin/bash\ninput=$(cat)\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path // \"\"')\nbasename=$(basename \"$file_path\")\nif [[ \"$file_path\" == *\"/.claude/\"* ]]; then\n  echo \"$input\"\n  exit 0\nfi\nif [[ \"$basename\" =~ ^(README|CLAUDE|CONTRIBUTING|CHANGELOG|LICENSE|AGENTS|ROADMAP|TASKS)\\.md$ ]]; then\n  echo \"$input\"\n  exit 0\nfi\necho \"[Hook] BLOCKED: Unnecessary documentation file creation\" >&2\nexit 1"</span>
          }
        ]
      }
    ],
    <span class="prop">"PostToolUse"</span>: [
      {
        <span class="prop">"matcher"</span>: <span class="string">"tool == \"Edit\" && tool_input.file_path matches \"\\\\.(ts|tsx|js|jsx)$\""</span>,
        <span class="prop">"hooks"</span>: [
          {
            <span class="prop">"type"</span>: <span class="string">"command"</span>,
            <span class="prop">"command"</span>: <span class="string">"#!/bin/bash\ninput=$(cat)\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path // \"\"')\nif [ -n \"$file_path\" ] && [ -f \"$file_path\" ]; then\n  console_logs=$(grep -n 'console\\\\.log' \"$file_path\" 2>/dev/null || true)\n  if [ -n \"$console_logs\" ]; then\n    echo \"[Hook] WARNING: console.log found in $file_path\" >&2\n    echo \"$console_logs\" | head -5 >&2\n  fi\nfi\necho \"$input\""</span>
          }
        ]
      }
    ]
  }
}</code></pre>

        <p><strong>What these do:</strong></p>
        <ul>
          <li><strong>PreToolUse (markdown gate):</strong> Blocks the agent from creating random .md files. Allows README.md, CLAUDE.md, and files inside .claude/.</li>
          <li><strong>PostToolUse (console.log):</strong> Warns when the agent leaves console.log statements in JS/TS files.</li>
        </ul>
      </div>
    </details>

    <details>
      <summary>Step 3: Create Project CLAUDE.md</summary>
      <div class="detail-content">
        <p>Every project gets one. Copy this template and customize:</p>
        <pre><code><span class="comment"># [Project Name]</span>

<span class="prop">**Purpose:**</span> [One sentence description]
<span class="prop">**Tech Stack:**</span> [Languages, frameworks]

---

<span class="keyword">## MANDATORY FIRST ACTION</span>

Before doing anything else each session:

1. Read <span class="string">`.claude/LAST_SESSION.md`</span> if it exists
2. Greet [Your Name] with context from prior session

<span class="prop">**If you skip this, you lose continuity.**</span>

---

<span class="keyword">## Learning &amp; Memory</span>

<span class="prop">**Core Principle:**</span> Learn once, remember forever.

<span class="prop">**Process:**</span> When corrected:
1. STOP the current task
2. UPDATE the relevant context file in .claude/context/
3. CONFIRM what you saved
4. PROCEED with the original task

---

<span class="keyword">## Key Directories</span>

| Directory | Purpose | Notes |
|-----------|---------|-------|
| src/ | Application source | [specifics] |
| tests/ | Test suite | [specifics] |

---

<span class="keyword">## Rules</span>

- Never paste credentials in chat or code
- [Your project-specific rules]
- [Your code style rules]

---

<span class="prop">**Last Updated:**</span> [date]</code></pre>
      </div>
    </details>

    <details>
      <summary>Step 4: Create Context Directory and Initial Context File</summary>
      <div class="detail-content">
        <pre><code><span class="comment"># Create the directory structure</span>
mkdir -p .claude/context .claude/hooks</code></pre>

        <p>Create your initial context file at <code>.claude/context/project.md</code>:</p>
        <pre><code><span class="comment"># [Project Name] - Context</span>

<span class="prop">**Last Updated:**</span> [date]

---

<span class="keyword">## Core Learnings</span>

<span class="comment">[This section will grow as the agent learns. Start empty.]</span>

---

<span class="keyword">## Gotchas &amp; Patterns</span>

<span class="comment">[Technical gotchas, API behaviors, schema quirks go here.]</span>

---

<span class="keyword">## Preferences &amp; Corrections</span>

<span class="comment">[Your stated preferences and corrections accumulate here.]</span></code></pre>

        <p>This file starts sparse. That is correct. It grows organically as the agent learns from your sessions.</p>
      </div>
    </details>

    <details>
      <summary>Step 5: Create the SessionStart Hook</summary>
      <div class="detail-content">
        <p>This is the most important hook. It generates <code>.claude/LAST_SESSION.md</code> every time a session starts.</p>

        <p>Create <code>.claude/hooks/session-context-review.sh</code>:</p>
        <pre><code>#!/bin/bash
<span class="comment"># SessionStart Hook - Context Review</span>
<span class="comment"># Generates LAST_SESSION.md with context file change report</span>

set -e

<span class="comment"># Pull latest changes (catches automated commits from CI/CD or collaborators)</span>
git pull --ff-only origin main 2>/dev/null || true

CONTEXT_DIR=".claude/context"
STATE_FILE=".claude/hooks/.last-session-state"
OUTPUT_FILE=".claude/LAST_SESSION.md"

CURRENT_TIME=$(date +%s)

<span class="comment"># Generate session report header</span>
cat > "$OUTPUT_FILE" << 'EOF'
# Last Session Status
**Auto-generated by SessionStart hook**
**Updated:**
EOF
echo "$(date '+%Y-%m-%d %H:%M:%S')" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

<span class="comment"># Check for context directory</span>
if [ ! -d "$CONTEXT_DIR" ]; then
  echo "Context directory not found: $CONTEXT_DIR" >> "$OUTPUT_FILE"
  exit 0
fi

<span class="comment"># Read or initialize last session timestamp</span>
if [ -f "$STATE_FILE" ]; then
  LAST_SESSION_TIME=$(cat "$STATE_FILE")
else
  LAST_SESSION_TIME=0
  echo "## First Session with Context System" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
fi
echo "$CURRENT_TIME" > "$STATE_FILE"

<span class="comment"># Check each context file for changes since last session</span>
CHANGES_FOUND=false
CHANGE_SUMMARY=""

for context_file in "$CONTEXT_DIR"/*.md; do
  if [ -f "$context_file" ]; then
    filename=$(basename "$context_file" .md)
    [[ "$filename" == "README" ]] && continue

    if [[ "$OSTYPE" == "darwin"* ]]; then
      mod_time=$(stat -f %m "$context_file")
      mod_date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$context_file")
    else
      mod_time=$(stat -c %Y "$context_file")
      mod_date=$(date -d "@$mod_time" "+%Y-%m-%d %H:%M")
    fi

    if [ $mod_time -gt $LAST_SESSION_TIME ]; then
      CHANGES_FOUND=true
      CHANGE_SUMMARY="${CHANGE_SUMMARY}- **${filename}**: Updated ${mod_date}\n"
    fi
  fi
done

<span class="comment"># Report findings</span>
if [ "$CHANGES_FOUND" = true ]; then
  echo "## Context Updates Since Last Session" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
  echo -e "$CHANGE_SUMMARY" >> "$OUTPUT_FILE"
else
  echo "## No Context Changes Since Last Session" >> "$OUTPUT_FILE"
fi
echo "" >> "$OUTPUT_FILE"

<span class="comment"># List available contexts with line counts</span>
echo "## Available Contexts" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
for context_file in "$CONTEXT_DIR"/*.md; do
  if [ -f "$context_file" ] && [[ ! "$context_file" =~ README ]]; then
    filename=$(basename "$context_file" .md)
    size=$(wc -l < "$context_file" | tr -d ' ')
    echo "- **${filename}** (${size} lines)" >> "$OUTPUT_FILE"
  fi
done

echo "" >> "$OUTPUT_FILE"
echo "---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "**Action:** Review context updates and greet with summary." >> "$OUTPUT_FILE"

exit 0</code></pre>

        <p>Make it executable:</p>
        <pre><code>chmod +x .claude/hooks/session-context-review.sh</code></pre>
      </div>
    </details>

    <details>
      <summary>Step 6: Wire Up the Hook in Project Settings</summary>
      <div class="detail-content">
        <p>Create <code>.claude/settings.json</code>:</p>
        <pre><code>{
  <span class="prop">"hooks"</span>: {
    <span class="prop">"SessionStart"</span>: [
      {
        <span class="prop">"matcher"</span>: <span class="string">"startup"</span>,
        <span class="prop">"hooks"</span>: [
          {
            <span class="prop">"type"</span>: <span class="string">"command"</span>,
            <span class="prop">"command"</span>: <span class="string">"bash .claude/hooks/session-context-review.sh"</span>,
            <span class="prop">"timeout"</span>: 30
          }
        ]
      }
    ]
  }
}</code></pre>

        <div class="callout callout-warning">
          <strong>Use relative paths in project hooks.</strong>
          The hook command runs from the project root. Using <code>bash .claude/hooks/session-context-review.sh</code> (relative) means the config works for any developer who clones the repo. Absolute paths break portability.
        </div>
      </div>
    </details>

    <details>
      <summary>Step 7: Install gitleaks Pre-commit Hook</summary>
      <div class="detail-content">
        <pre><code><span class="comment"># Install gitleaks (macOS)</span>
brew install gitleaks

<span class="comment"># Create the pre-commit hook</span>
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
gitleaks protect --staged --verbose
EOF
chmod +x .git/hooks/pre-commit</code></pre>

        <p>Test it by staging a file with a fake secret:</p>
        <pre><code><span class="comment"># This should be caught and blocked</span>
echo 'API_KEY="sk-ant-api03-fake-key-for-testing"' > /tmp/test-leak.txt
cp /tmp/test-leak.txt .
git add test-leak.txt
git commit -m "test"  <span class="comment"># Should fail with gitleaks warning</span>
git checkout -- test-leak.txt
rm test-leak.txt</code></pre>
      </div>
    </details>

    <details>
      <summary>Step 8: Configure .gitignore</summary>
      <div class="detail-content">
        <p>Add these patterns to your <code>.gitignore</code>:</p>
        <pre><code><span class="comment"># Secrets</span>
.env
.env.*
*.key
*.pem
service-account*.json
credentials*.json

<span class="comment"># Claude Code session artifacts</span>
.claude/LAST_SESSION.md
.claude/hooks/.last-session-state

<span class="comment"># Session transcripts</span>
*.jsonl

<span class="comment"># OS artifacts</span>
.DS_Store
Thumbs.db</code></pre>
      </div>
    </details>

    <details>
      <summary>Step 9: Verify the Setup</summary>
      <div class="detail-content">
        <p>Start a Claude Code session in your project. You should see:</p>
        <ol>
          <li>The SessionStart hook fires (you will see "success" in the session output)</li>
          <li><code>.claude/LAST_SESSION.md</code> is generated</li>
          <li>The agent reads LAST_SESSION.md as its first action (per CLAUDE.md instructions)</li>
          <li>The agent greets you with context</li>
        </ol>
        <p>If the hook does not fire, check:</p>
        <ul>
          <li>Is <code>.claude/settings.json</code> valid JSON? (use <code>jq . .claude/settings.json</code>)</li>
          <li>Is the hook script executable? (<code>ls -la .claude/hooks/</code>)</li>
          <li>Does the hook script run standalone? (<code>bash .claude/hooks/session-context-review.sh</code>)</li>
        </ul>
      </div>
    </details>
  </section>

  <!-- ============================================================ -->
  <section id="security">
    <h2>4. Security Checklist</h2>

    <h3>Pre-Commit: gitleaks</h3>
    <p>Every repository that touches credentials, API keys, or client data needs gitleaks. No exceptions.</p>

    <table>
      <tr><th>Risk</th><th>Without gitleaks</th><th>With gitleaks</th></tr>
      <tr><td>Accidental credential commit</td><td>Enters git history. Requires force push + history rewrite to remove. If pushed to remote, credential is compromised.</td><td>Blocked at commit time. Never enters history.</td></tr>
      <tr><td>Cost of remediation</td><td>Rotate credential + scrub history + force push + notify downstream</td><td>Fix the file, re-stage, commit again</td></tr>
    </table>

    <h3>.gitignore Patterns</h3>
    <p>These patterns should be in every project's <code>.gitignore</code>:</p>
    <pre><code>.env
.env.*
*.key
*.pem
service-account*.json
credentials*.json
.claude/LAST_SESSION.md
.claude/hooks/.last-session-state</code></pre>

    <h3>Credential Handling Rules</h3>

    <div class="callout callout-danger">
      <strong>Never paste credentials into Claude Code chat.</strong>
      They end up in session transcripts stored at <code>~/.claude/projects/</code>. These transcripts are plaintext JSON. Anyone with disk access can read them.
    </div>

    <table>
      <tr><th>Do</th><th>Do Not</th></tr>
      <tr><td>Reference environment variables: <code>$API_KEY</code></td><td>Paste literal key values in chat</td></tr>
      <tr><td>Store secrets in <code>.env</code> files (gitignored)</td><td>Hardcode secrets in source files</td></tr>
      <tr><td>Use macOS Keychain for sensitive tokens</td><td>Store tokens in plaintext outside of git</td></tr>
      <tr><td>Rotate immediately if a credential appears in git history</td><td>Assume removing the file is sufficient</td></tr>
    </table>

    <h3>The --dangerously-skip-permissions Flag</h3>

    <p>This flag gives Claude Code unrestricted filesystem and network access. It exists for headless automation where there is no interactive user to approve tool calls.</p>

    <table>
      <tr><th>Appropriate</th><th>Not Appropriate</th></tr>
      <tr><td>Automated overnight jobs on your machine</td><td>Shared machines or team environments</td></tr>
      <tr><td>CI/CD pipelines you control end-to-end</td><td>Contexts where untrusted input reaches the agent</td></tr>
      <tr><td>Cron/launchd jobs under your user account</td><td>Without reviewing the prompt the agent receives</td></tr>
    </table>

    <div class="callout callout-warning">
      <strong>Prompt injection risk.</strong>
      Any input the agent reads -- files, transcripts, API responses -- can contain instructions that the agent may follow. With <code>--dangerously-skip-permissions</code>, those instructions execute without approval. The mitigation is to constrain inputs and review outputs. This is adequate for a solo operator. It does not scale to teams.
    </div>

    <h3>Session Transcript Hygiene</h3>
    <p>Session transcripts accumulate indefinitely at <code>~/.claude/projects/</code>. They contain the full text of every conversation, including any data discussed. Set up periodic cleanup:</p>
    <pre><code><span class="comment"># Monthly cleanup: delete transcripts older than 30 days</span>
find ~/.claude/projects/ -name "*.jsonl" -mtime +30 -delete</code></pre>
  </section>

  <!-- ============================================================ -->
  <section id="maintenance">
    <h2>5. Maintenance &amp; Hygiene</h2>

    <h3>Context File Growth</h3>
    <p>Context files grow naturally as the agent learns. This is by design. But unchecked growth dilutes signal and consumes context window.</p>

    <table>
      <tr><th>Action</th><th>Frequency</th><th>Why</th></tr>
      <tr><td>Review context files for redundancy</td><td>Monthly</td><td>Duplicate entries accumulate (agent captures same learning from multiple sessions)</td></tr>
      <tr><td>Consolidate MEMORY.md</td><td>When approaching 180 lines</td><td>Silent truncation at 200 lines loses knowledge</td></tr>
      <tr><td>Archive stale entries</td><td>Quarterly</td><td>Setup notes, resolved issues, and superseded patterns add noise</td></tr>
      <tr><td>Full context audit</td><td>Every 6 months</td><td>Verify accuracy against current codebase state</td></tr>
    </table>

    <h3>MEMORY.md Overflow Management</h3>
    <p>When MEMORY.md approaches 180 lines:</p>
    <ol>
      <li>Identify sections with detailed content (multi-line entries with examples)</li>
      <li>Create topic files in the same memory directory: <code>schema-gotchas.md</code>, <code>deployment-notes.md</code></li>
      <li>Move the detailed content into topic files</li>
      <li>Replace the original entries in MEMORY.md with one-line pointers: <code>## Schema Gotchas -- see schema-gotchas.md</code></li>
      <li>The agent can read topic files on demand; they just are not auto-loaded</li>
    </ol>

    <h3>What to Prune</h3>
    <table>
      <tr><th>Prune</th><th>Keep</th></tr>
      <tr><td>Issues that have been permanently fixed</td><td>Gotchas that could recur (API behaviors, schema quirks)</td></tr>
      <tr><td>Duplicate entries</td><td>Your stated preferences and corrections</td></tr>
      <tr><td>Early-stage setup notes</td><td>Architectural decisions and their rationale</td></tr>
      <tr><td>Entries superseded by newer information</td><td>Security rules and credential handling patterns</td></tr>
    </table>

    <h3>Compound Review (Advanced)</h3>
    <p>For high-use projects, an automated nightly review extracts learnings from the day's session transcripts and appends them to context files. This is how the most mature Claude Code environments work:</p>
    <ol>
      <li>A cron job runs at a fixed time (e.g., 10:30 PM)</li>
      <li>It finds session transcripts from the last 24 hours</li>
      <li>It runs Claude Code with <code>--dangerously-skip-permissions</code> to review the transcripts</li>
      <li>Claude extracts new learnings and appends them to context files</li>
      <li>The script commits and pushes the changes</li>
    </ol>
    <p>This is optional and requires comfort with headless Claude Code automation. Start with manual context management. Graduate to automated compound review when you have a project with daily sessions.</p>
  </section>

  <!-- ============================================================ -->
  <section id="quickstart">
    <h2>6. Quick-Start Template</h2>

    <p>Everything you need to set up a new project, in one block. Copy, customize, deploy.</p>

    <details open>
      <summary>One-Command Setup Script</summary>
      <div class="detail-content">
        <p>Save this as <code>setup-claude-code.sh</code> and run it from your project root:</p>
        <pre><code>#!/bin/bash
<span class="comment"># setup-claude-code.sh</span>
<span class="comment"># Sets up Claude Code persistent infrastructure for a project.</span>
<span class="comment"># Run from project root: bash setup-claude-code.sh "Project Name" "Your Name"</span>

set -euo pipefail

PROJECT_NAME="${1:?Usage: bash setup-claude-code.sh \"Project Name\" \"Your Name\"}"
OWNER_NAME="${2:?Usage: bash setup-claude-code.sh \"Project Name\" \"Your Name\"}"
TODAY=$(date '+%Y-%m-%d')

echo "Setting up Claude Code for: $PROJECT_NAME"
echo ""

<span class="comment"># 1. Create directory structure</span>
mkdir -p .claude/context .claude/hooks
echo "  Created .claude/context/ and .claude/hooks/"

<span class="comment"># 2. Create CLAUDE.md</span>
if [ ! -f CLAUDE.md ]; then
cat > CLAUDE.md << CLAUDEEOF
# $PROJECT_NAME

**Auto-loaded at every session start**

---

## MANDATORY FIRST ACTION

Before doing anything else each session:
1. Read \`.claude/LAST_SESSION.md\` if it exists
2. Greet $OWNER_NAME with context from prior session

---

## Learning & Memory

**Core Principle:** Learn once, remember forever.

**Process:** When corrected:
1. STOP the current task
2. UPDATE .claude/context/project.md
3. CONFIRM what you saved
4. PROCEED with the original task

---

## Rules

- Never paste credentials in chat or code
- Use environment variables for all secrets

---

**Last Updated:** $TODAY
CLAUDEEOF
echo "  Created CLAUDE.md"
else
  echo "  CLAUDE.md already exists -- skipping"
fi

<span class="comment"># 3. Create initial context file</span>
if [ ! -f .claude/context/project.md ]; then
cat > .claude/context/project.md << CTXEOF
# $PROJECT_NAME - Context

**Last Updated:** $TODAY

---

## Core Learnings

---

## Gotchas & Patterns

---

## Preferences & Corrections

CTXEOF
echo "  Created .claude/context/project.md"
fi

<span class="comment"># 4. Create SessionStart hook</span>
cat > .claude/hooks/session-context-review.sh << 'HOOKEOF'
#!/bin/bash
set -e
git pull --ff-only origin main 2>/dev/null || true
CONTEXT_DIR=".claude/context"
STATE_FILE=".claude/hooks/.last-session-state"
OUTPUT_FILE=".claude/LAST_SESSION.md"
CURRENT_TIME=$(date +%s)

cat > "$OUTPUT_FILE" << 'EOF'
# Last Session Status
**Auto-generated by SessionStart hook**
**Updated:**
EOF
echo "$(date '+%Y-%m-%d %H:%M:%S')" >> "$OUTPUT_FILE"
echo -e "\n---\n" >> "$OUTPUT_FILE"

if [ ! -d "$CONTEXT_DIR" ]; then
  echo "Context directory not found." >> "$OUTPUT_FILE"
  exit 0
fi

LAST_SESSION_TIME=0
[ -f "$STATE_FILE" ] && LAST_SESSION_TIME=$(cat "$STATE_FILE")
echo "$CURRENT_TIME" > "$STATE_FILE"

CHANGES_FOUND=false
CHANGE_SUMMARY=""
for f in "$CONTEXT_DIR"/*.md; do
  [ -f "$f" ] || continue
  name=$(basename "$f" .md)
  [[ "$name" == "README" ]] && continue
  if [[ "$OSTYPE" == "darwin"* ]]; then
    mt=$(stat -f %m "$f"); md=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$f")
  else
    mt=$(stat -c %Y "$f"); md=$(date -d "@$mt" "+%Y-%m-%d %H:%M")
  fi
  if [ $mt -gt $LAST_SESSION_TIME ]; then
    CHANGES_FOUND=true
    CHANGE_SUMMARY="${CHANGE_SUMMARY}- **${name}**: Updated ${md}\n"
  fi
done

if [ "$CHANGES_FOUND" = true ]; then
  echo "## Context Updates Since Last Session" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
  echo -e "$CHANGE_SUMMARY" >> "$OUTPUT_FILE"
else
  echo "## No Context Changes Since Last Session" >> "$OUTPUT_FILE"
fi

echo "" >> "$OUTPUT_FILE"
echo "## Available Contexts" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
for f in "$CONTEXT_DIR"/*.md; do
  [ -f "$f" ] || continue
  [[ "$f" =~ README ]] && continue
  name=$(basename "$f" .md)
  size=$(wc -l < "$f" | tr -d ' ')
  echo "- **${name}** (${size} lines)" >> "$OUTPUT_FILE"
done
exit 0
HOOKEOF
chmod +x .claude/hooks/session-context-review.sh
echo "  Created and enabled SessionStart hook"

<span class="comment"># 5. Create project settings.json</span>
cat > .claude/settings.json << 'SETTINGSEOF'
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup",
        "hooks": [
          {
            "type": "command",
            "command": "bash .claude/hooks/session-context-review.sh",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
SETTINGSEOF
echo "  Created .claude/settings.json"

<span class="comment"># 6. Install gitleaks pre-commit hook</span>
if command -v gitleaks &> /dev/null; then
  if [ -d .git ]; then
    cat > .git/hooks/pre-commit << 'GLEOF'
#!/bin/bash
gitleaks protect --staged --verbose
GLEOF
    chmod +x .git/hooks/pre-commit
    echo "  Installed gitleaks pre-commit hook"
  else
    echo "  Not a git repo -- skipping gitleaks hook"
  fi
else
  echo "  gitleaks not installed -- run: brew install gitleaks"
fi

<span class="comment"># 7. Update .gitignore</span>
GITIGNORE_PATTERNS=".env
.env.*
*.key
*.pem
service-account*.json
credentials*.json
.claude/LAST_SESSION.md
.claude/hooks/.last-session-state"

if [ -f .gitignore ]; then
  for pattern in $GITIGNORE_PATTERNS; do
    if ! grep -qF "$pattern" .gitignore 2>/dev/null; then
      echo "$pattern" >> .gitignore
    fi
  done
  echo "  Updated .gitignore with security patterns"
else
  echo "$GITIGNORE_PATTERNS" > .gitignore
  echo "  Created .gitignore"
fi

echo ""
echo "Done. Claude Code infrastructure is ready."
echo ""
echo "Next steps:"
echo "  1. Start a claude session to verify the hook fires"
echo "  2. Customize CLAUDE.md with project-specific rules"
echo "  3. Add domain knowledge to .claude/context/project.md as you work"
echo ""</code></pre>

        <p><strong>Usage:</strong></p>
        <pre><code>bash setup-claude-code.sh "My Project" "Scott Shirey"</code></pre>
      </div>
    </details>

    <h3>Quick-Start Checklist</h3>
    <ul class="checklist">
      <li>Run the setup script (or do each step manually)</li>
      <li>Create <code>~/.claude/CLAUDE.md</code> if it does not exist (global config)</li>
      <li>Start a Claude Code session and verify the SessionStart hook fires</li>
      <li>Customize CLAUDE.md with your project-specific rules</li>
      <li>After your first few sessions, review MEMORY.md to verify it is capturing learnings</li>
      <li>Review context files monthly for growth and redundancy</li>
      <li>If handling client data: verify gitleaks blocks a test secret before committing real work</li>
    </ul>

    <h3>What Good Looks Like After 2 Weeks</h3>
    <table>
      <tr><th>Indicator</th><th>Healthy</th><th>Needs Attention</th></tr>
      <tr><td>CLAUDE.md</td><td>Under 100 lines, focused on rules and mandatory actions</td><td>Over 200 lines, full of tutorials and examples</td></tr>
      <tr><td>Context files</td><td>10-50 entries, each date-stamped, no duplicates</td><td>Fewer than 5 entries (agent is not learning) or 200+ lines of noise</td></tr>
      <tr><td>MEMORY.md</td><td>Under 150 lines, organized by topic</td><td>Over 200 lines (being truncated), or empty (auto-memory disabled?)</td></tr>
      <tr><td>Session start</td><td>Agent greets you with context, mentions recent changes</td><td>Agent asks "What are we working on?" every session</td></tr>
      <tr><td>Correction retention</td><td>Correct the agent once, it remembers next session</td><td>Correcting the same thing repeatedly</td></tr>
    </table>
  </section>

  <hr>

  <div class="footer">
    <p>Dr. Nadia Okafor -- Independent Platform Architect</p>
    <p>February 24, 2026</p>
    <p style="margin-top: 12px; font-size: 11px; color: #a09a94;">Based on a production audit of a mature multi-project Claude Code deployment.<br>No credentials, project-specific data, or PII are included in this guide.</p>
  </div>

</div>

<script>
  // Add copy buttons to code blocks
  document.querySelectorAll('pre').forEach(pre => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.addEventListener('click', () => {
      const code = pre.querySelector('code') || pre;
      const text = code.textContent;
      navigator.clipboard.writeText(text).then(() => {
        btn.textContent = 'Copied';
        setTimeout(() => btn.textContent = 'Copy', 1500);
      });
    });
    pre.style.position = 'relative';
    pre.appendChild(btn);
  });
</script>
</body>
</html>
